/*
*
*   -- WebtermCom.JS --
*
* 	Copyright (C) 2018 Christian Visintin - christian.visintin1997@gmail.com
*
* 	This file is part of WebTermJS
*
*   WebTermJS is free software: you can redistribute it and/or modify
*   it under the terms of the GNU General Public License as published by
*   the Free Software Foundation, either version 3 of the License, or
*   (at your option) any later version.
*
*   WebTermJS is distributed in the hope that it will be useful,
*   but WITHOUT ANY WARRANTY; without even the implied warranty of
*   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*   GNU General Public License for more details.
*
*   You should have received a copy of the GNU General Public License
*   along with WebTermJS.  If not, see <http://www.gnu.org/licenses/>.
*
*/

var fs = require('fs');
var shell = require('../processJS/process.js');

var blacklist = [];

/*
* Execute command
* @param: string path 
* @param: array of Strings command
* @return: response object
*/

exports.exec = function(path, commandArg) {
    //Command is the first element of the command array
    var command = commandArg[0];
    //Argv are all the arguments after the first
    var argv = commandArg.splice(1);
    //Check if command is blacklisted
    if(isBlacklisted(command)) {
        return err_commandNotFound(path);
    }
    //Else command is allowed
    switch(command) {
        case "cd":
        return ex_cd(path, argv);

        case "cat":
        return ex_cat(path, argv);

        //case "rm":
        //return ex_rm(path, argv);

        case "touch":
        return ex_touch(path, argv);

        //case "ln":
        //return ex_ln(path, argv);

        //Text editor
        case "###SAVEFILE~":
        return ex_SAVEFILE(path, argv);

        case "###CREATEFILE~":
        return ex_CREATEFILE(path, argv);

        default:
        return ex_genericPurposeCommand(path, command, argv);

    }
};

//Webterm utils

exports.setBlacklist = function(blacklistArray) {
    blacklist = blacklistArray;
};

function isBlacklisted(command) {
    return (blacklist.indexOf('command') > -1);
};

function buildResponse(path, response) {
    var responseObj = {path: path, response: response};
    return responseObj;
};

/*
* Returns the absolute path in case of relative paths
* @param: string oldPath -> contains the current path of the user (the one passed in path variable)
* @param: string newPath -> The path the user wants to reach
* @return: string -> absolute path resolved using the old and the new path
*/

function resolvePath(oldPath, newPath, isDir) {

    if(newPath.charAt(newPath.length - 1) != '/' && isDir)
        newPath += '/';

    //Add trailing slash to oldPath
    if(oldPath.substring(oldPath.length - 1) != '/') {
        oldPath += '/';
    }

    //Is the current path
    if(newPath == "./") {
        return oldPath;
    }

    //Resolve root /..
    if(newPath == "/../") {
        return "/";
    }

    //Check if user required previous path
    if(newPath == "../") {
        var tmpPath = oldPath.substring(0, oldPath.lastIndexOf('/'));
        console.log("Tmp: ", tmpPath);
        return tmpPath.substring(0, tmpPath.lastIndexOf('/') + 1);
    }

    //It's relative starting from oldPath
    if(newPath.charAt(0) != '/') {
        return oldPath + newPath;
    }
    else {
        return newPath;
    }

}

function isAFile(path) {
    try {
        var fileStats = fs.lstatSync(path);
        if(fileStats.isFile()) {
            return true;
        }
        else {
            return false;
        }
    }
    catch(e) {
        return false;
    }
}

function isADirectory(path) {
    try {
        var fileStats = fs.lstatSync(path);
        if(fileStats.isDirectory()) {
            return true;
        }
        else {
            return false;
        }
    }
    catch(e) {
        return false;
    }
}

function pathExists(path) {
    return fs.existsSync(path);
}

//Commands execution functions

function ex_cd(path, argv) {
    var destDir = resolvePath(path, argv[0], true);
    console.log("DestDir is", destDir);
    if(!pathExists(destDir)) {
        return err_noFile(path);
    }
    if(!isADirectory(destDir)) {
        return err_isNotDir(path);
    }
    return buildResponse(destDir, null);
}

function ex_touch(path, argv) {
    var pathDest = resolvePath(path, argv[0], false);
    if(pathExists(pathDest)) {
        if(!isAFile(pathDest)) {
            return err_isNotFile(path);
        }
        else {
            return buildResponse(path, null);
        }
    }
    //It exists and is a file or it doesn't exist -> TOUCH file
    fs.open(pathDest, 'w', function(err, file) {
        if(err) return err_pex(path);
    });

    return buildResponse(path, null);

}

function ex_cat(path, argv) {
    var content = "";
    //Read all files listed in argv
    for(var i = 0; i < argv.length; i++) {
        var fileToRead = resolvePath(path, argv[i], false);
        if(pathExists(fileToRead)) {
            if(isAFile(fileToRead)) {
                content += fs.readFileSync(fileToRead).toString() + "\n\n";
            }
            else {
                content += fileToRead + " is not a file\n\n";
            }
        }
        else {
            content += fileToRead + ": no such file or directory\n\n";
        }
    }
    return buildResponse(path, content);
}

//Creates file or read it for text editor
function ex_CREATEFILE(path, argv) {
    var editFile = resolvePath(path, argv[0], false);
    var content = "";
    if(pathExists(editFile)) {
        if(isAFile(editFile)) {
            content = fs.readFileSync(editFile).toString();
        }
        else {
            return err_isNotFile(path);
        }
    }
    else {
        fs.open(editFile, 'w', function(err, file) {
            if(err) return err_pex(path);
        });
    }

    return buildResponse(path, content);

}

/*
* Save edited file
* argv[0]: file path
* argv[1]: content to write
*/

function ex_SAVEFILE(path, argv) {
    var fileToSave = resolvePath(path, argv[0], false);
    var content = argv[1];
    fs.writeFileSync(fileToSave, content);
    return buildResponse(path, null);
}

function ex_genericPurposeCommand(path, command, argv) {
    if(pathExists(path)) {
        if(isADirectory(path)) {
            process.chdir(path);
            command += " ";
            for(var i = 0; i < argv.length; i++)
                command += " " + argv[i];
            var stdout = shell.shellExec(command);
            return buildResponse(path, stdout);
        }
        return err_isNotDir(path);
    }
    return err_noFile(path);
}

//Error message functions

function err_commandNotFound(path) {
    return buildResponse(path, "Error: command not found!\n");
};

function err_noFile(path) {
    return buildResponse(path, "No such file or directory!\n");
};

function err_isDir(path) {
    return buildResponse(path, "Is a directory!\n");
};

function err_isNotDir(path) {
    return buildResponse(path, "It is not a directory!\n");
};

function err_isNotFile(path) {
    return buildResponse(path, "It is not a file!\n");
}

function err_pex(path) {
    return buildResponse(path, "You don't have enough permissions to do this!\n");
}